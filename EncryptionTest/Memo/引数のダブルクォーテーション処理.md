```markdown
# Windows におけるコマンドライン引数とダブルクォーテーションの扱いまとめ

## 1. 結論

- `Main(string[] args)` で受け取る引数では  
  **ダブルクォーテーションは基本的に削除される**
- これは Windows 側の引数分解処理によるもの
- その分解に使われるのが **Win32 API `CommandLineToArgvW`**

---

## 2. Windows のプロセス起動の仕組み

Windows では、プロセスは以下の流れで起動する：

```

CreateProcessW()
↓
新しいプロセス開始
↓
プロセスには「1本のコマンドライン文字列」が渡る
↓
ランタイム（Cランタイム / CLR）が
CommandLineToArgvW を使って分解
↓
Main(string[] args) に配列として渡される

````

### 重要ポイント

Windows カーネルは：

- 引数配列を持っていない
- ただの「1本の文字列」を渡しているだけ

---

## 3. CommandLineToArgvW とは？

### 概要

- **Win32 API**
- `shell32.dll` に実装
- Unicode 版（末尾の `W` は Wide の意味）

### C言語シグネチャ

```c
LPWSTR *CommandLineToArgvW(
  LPCWSTR lpCmdLine,
  int     *pNumArgs
);
````

---

## 4. なぜダブルクォーテーションが消えるのか？

ダブルクォーテーションは：

* 文字データではない
* 引数分解のための「構文記号」

つまり：

```
"C:\my folder\test.csv"
```

は

```
「ここからここまでを1つの引数として扱う」
```

という意味の **制御記号** であり、

分解後は役目を終えるため削除される。

---

## 5. 具体例

### 入力（元のコマンドライン）

```
AppB.exe /L"C:\my folder\test.csv"
```

### 分解後（Main の args）

```
args[0] = "/LC:\my folder\test.csv"
```

* 空白は保持される
* ダブルクォーテーションは削除される

---

## 6. 空白が無くても削除される理由

```
/L"C:\temp\test.csv"
```

この場合も：

* `"` はグルーピング記号
* 文字データではない

ため削除される。

---

## 7. クォートを文字として渡したい場合

エスケープが必要：

```
/L\"abc\"
```

この場合：

* `\"` は文字としての `"`
* 実際の文字列に残る

---

## 8. .NET Framework 4.7 の場合

`.NET Framework` では：

* CLR が起動時にコマンドラインを取得
* Win32 API ルールで分解
* `string[] args` を生成

つまり：

```
args[] はすでにパース済みの結果
```

---

## 9. 生のコマンドラインを取得する方法

```csharp
string raw = Environment.CommandLine;
```

これは：

* 分解前の文字列
* クォートもそのまま含まれる

---

## 10. まとめ

| 項目            | 内容                      |
| ------------- | ----------------------- |
| クォートを消すのは？    | CommandLineToArgvW      |
| それは何？         | Win32 API               |
| OSカーネルがやる？    | いいえ                     |
| Windowsは何を渡す？ | 1本の文字列                  |
| args[]は？      | 分解済み配列                  |
| 生文字列の取得方法     | Environment.CommandLine |

---

## 11. 補足

* ネイティブアプリ → Cランタイムが分解
* .NETアプリ → CLRが分解
* どちらも同じ Windows の分解ルールに従う

---

以上。

```
```
